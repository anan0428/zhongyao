<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ä¸­è¯é…æ–¹</title>
  <style>
    :root{--bg:#f6f8fb;--card:#ffffff;--muted:#6b7280;--accent:#7c3aed;--radius:12px}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;background:#f8fafc}
    .app{padding:14px;max-width:540px;margin:auto}

    header{margin-bottom:10px}
    h1{font-size:18px;margin:0 0 4px 0}
    p.lead{margin:0;color:var(--muted);font-size:13px}

    /* ä¸¤è¡Œå¸¦å›¾æ ‡æ ‡ç­¾ */
    .tabs{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:8px;
    }
    .tab{
      background:var(--card);
      padding:6px 10px 6px 8px;
      border-radius:20px;
      font-size:13px;
      border:1px solid transparent;
      cursor:pointer;
      box-shadow:0 2px 6px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      gap:8px;
      min-height:40px;
    }
    .tab .icon{font-size:18px;line-height:1;flex-shrink:0}
    .tab span{display:inline-block;max-width:120px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}
    .tab.active{border-color:var(--accent);color:var(--accent);font-weight:600}

    /* ä¸»å†…å®¹å¡ç‰‡ */
    .card-main{background:var(--card);border-radius:var(--radius);padding:14px;margin-top:10px;box-shadow:0 8px 20px rgba(0,0,0,0.06)}
    .hero{display:flex;gap:12px;align-items:flex-start}
    .hero .pic{width:140px;height:140px;border-radius:10px;overflow:hidden;background:#eee;flex-shrink:0;position:relative}
    .hero img{width:100%;height:100%;object-fit:cover;display:block;transition:opacity 0.3s ease}
    .hero img.loading{opacity:0.5}
    h2{margin:0;font-size:17px}
    .meta{font-size:13px;color:var(--muted);margin-top:4px}

    .section{margin-top:12px}
    .label{font-size:13px;color:var(--muted);margin-bottom:6px}
    .box{background:#fdfefe;padding:10px;border-radius:10px;font-size:14px;border:1px solid rgba(0,0,0,0.04)}

    /* åœºæ™¯å¤§å›¾æ ·å¼ï¼šæ¯å¼ ç‹¬å ä¸€è¡Œï¼Œå°ºå¯¸æ›´å¤§ */
    .scene-img{width:100%;height:180px;object-fit:cover;border-radius:8px;background:#f3f4f6;display:block;transition:opacity 0.3s ease}
    .scene-img.loading{opacity:0.5}
    .scene-text{margin-top:8px;color:var(--muted);font-size:14px}

    footer{margin-top:14px;display:flex;gap:10px}
    .btn{flex:1;padding:10px;border:0;border-radius:10px;font-weight:600;background:var(--accent);color:#fff}

    /* åŠ è½½åŠ¨ç”» */
    .loading-shimmer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        rgba(255,255,255,0) 0%, 
        rgba(255,255,255,0.8) 50%, 
        rgba(255,255,255,0) 100%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: inherit;
    }
    
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }
    
    @media (max-width:420px){.tab span{max-width:90px}.hero .pic{width:110px;height:110px}.scene-img{height:120px}}
  </style>
</head>
<body>
<div class="app">
  <header>
    <h1>ä¸­è¯é…æ–¹é€ŸæŸ¥</h1>
    <p class="lead"></p>
  </header>

  <!-- ä¸¤è¡Œå›¾æ ‡æ ‡ç­¾æ  -->
  <div class="tabs" id="tabs" aria-label="é…æ–¹åˆ†ç±»"></div>

  <div class="card-main" role="region" aria-live="polite">
    <div class="hero">
      <div class="pic" id="detail-pic">
        <img src="" alt="äº§å“å›¾å ä½">
        <div class="loading-shimmer" style="display:none" id="main-loading"></div>
      </div>
      <div style="flex:1">
        <h2 id="detail-title">è¯·é€‰æ‹©é¡¹ç›®</h2>
        <div class="meta" id="detail-sub">é€‰æ‹©ä¸Šæ–¹ä»»ä¸€æ ‡ç­¾æŸ¥çœ‹è¯¦æƒ…</div>
      </div>
    </div>

    <div class="section">
      <div class="label">é…æ–¹</div>
      <div class="box" id="detail-formula">â€”</div>
    </div>

    <!-- åœºæ™¯ä¸€ï¼ˆç‹¬å ä¸€è¡Œï¼‰ -->
    <div class="section">
      <div class="label">ä½¿ç”¨åœºæ™¯ 1</div>
      <div class="box">
        <img src="" alt="åœºæ™¯1å ä½å›¾" id="detail-scene1" class="scene-img">
        <div id="detail-scene1-text" class="scene-text">â€”</div>
      </div>
    </div>

    <!-- åœºæ™¯äºŒï¼ˆç‹¬å ä¸€è¡Œï¼‰ -->
    <div class="section">
      <div class="label">ä½¿ç”¨åœºæ™¯ 2</div>
      <div class="box">
        <img src="" alt="åœºæ™¯2å ä½å›¾" id="detail-scene2" class="scene-img">
        <div id="detail-scene2-text" class="scene-text">â€”</div>
      </div>
    </div>

    <footer>
      <button class="btn" id="btn-copy">å¤åˆ¶é…æ–¹</button>
    </footer>
  </div>
</div>

<script>
// æœ¬ç‰ˆæœ¬ä¸¥æ ¼æ ¹æ®ä½ ä¸Šä¼ çš„æ–‡æ¡£æ–‡æœ¬ï¼ˆå·²å¼•ç”¨ï¼‰æ„å»º ITEMS å†…å®¹ã€‚è¯¦è§ï¼šæ–‡æ¡£"ä¸­è¯é…æ–¹.docx"ã€‚
// æ•°æ®æ¥è‡ªç”¨æˆ·ä¸Šä¼ æ–‡ä»¶å¹¶é€æ¡å¡«å…¥ä¸ºï¼štitle / subtitle / formula / æ›´å¤šé€‚ç”¨åœºæ™¯ï¼ˆå·²æ‹†ä¸ºåœºæ™¯1/åœºæ™¯2ï¼‰
const ITEMS = [
  {id:'insomnia', title:'å¤±çœ /å‹åŠ›å¤§', icon:'ğŸŒ™', sub:'å®‰ç¥åŠ©çœ æ¬¾', scene1Text:'é…’åº—å®¢æˆ¿é¤', scene2Text:'æ·±å¤œä¾¿åˆ©åº—', formula:'é¢ç²‰+é…¸æ£ä»+èŒ¯è‹“+è¿œå¿—'},
  {id:'children', title:'å„¿ç«¥/ç§¯é£Ÿäººç¾¤', icon:'ğŸ§’', sub:'å¥è„¾æ¶ˆç§¯æ¬¾', scene1Text:'äº²å­é¤å…', scene2Text:'å¹¼å„¿å›­é…é¤', formula:'é¢ç²‰+é¸¡å†…é‡‘+éº¦èŠ½+å±±æ¥‚'},
  {id:'cold', title:'ç•å¯’/ä½æ¸©', icon:'â„ï¸', sub:'å¾¡å¯’æš–èº«æ¬¾', scene1Text:'ç«é”…åº—é™„é¤', scene2Text:'ç¤¾åŒºæ—©é¤è½¦', formula:'é¢ç²‰+ç”Ÿå§œ+çº¢ç³–+è‚‰'},
  {id:'anxiety', title:'ç„¦è™‘/è‚æ°”éƒç»“', icon:'ğŸ§­', sub:'ç–è‚ç†æ°”æ¬¾', scene1Text:'èŒåœºè½»é£Ÿåº—', scene2Text:'å¿ƒç†å’¨è¯¢å®¤é…å¥—é¤', formula:'é¢ç²‰+ä½›æ‰‹+é¦™æ©¼+é™ˆçš®'},
  {id:'fatigue', title:'ç†¬å¤œè‚¾è™š/ç²¾åŠ›ä¸è¶³', icon:'âš¡', sub:'ç›Šè‚¾å›ºç²¾æ¬¾', scene1Text:'ç”·å£«å…»ç”Ÿä¼šæ‰€', scene2Text:'ç”µç«é…’åº—é¤é£Ÿ', formula:'é¢ç²‰+èŠ¡å®+è²å­+å±±è¯'},
  {id:'throat', title:'ç”¨å—“è¿‡åº¦/å’½å–‰ä¸é€‚', icon:'ğŸ¤', sub:'æ¸…å’½æ¶¦å–‰æ¬¾', scene1Text:'KTVé…å¥—é¤', scene2Text:'æ•™å¸ˆé£Ÿå ‚', formula:'é¢ç²‰+ç½—æ±‰æœ+æ¡”æ¢—+ç™¾åˆ'},
  {id:'water', title:'ä¹…åæ°´è‚¿/ä»£è°¢ç¼“æ…¢', icon:'ğŸ’§', sub:'æ¶ˆè„‚æ’æµŠæ¬¾', scene1Text:'ç‘œä¼½é¦†è½»é£ŸåŒº', scene2Text:'é€šå‹¤ä¾¿åˆ©åº—', formula:'é¢ç²‰+å†³æ˜å­+èŒ¯è‹“+å†¬ç“œ'},
  {id:'stomach', title:'èƒƒå¯’/ç§‹å†¬èƒƒç—›', icon:'ğŸœ', sub:'æ¸©èƒƒæ•£å¯’æ¬¾', scene1Text:'åŒ—æ–¹æ—©é¤æ‘Š', scene2Text:'ç¤¾åŒºä¾¿æ°‘é£Ÿå ‚', formula:'é¢ç²‰+å°èŒ´é¦™+å¹²å§œ+èƒ¡æ¤’'}
];

// å›¾ç‰‡åŸºç¡€è·¯å¾„
const IMG_BASE_PATH = './img/';

// å¢å¼ºç‰ˆå›¾ç‰‡ç¼“å­˜ï¼šå­˜å‚¨å›¾ç‰‡æ•°æ®å’ŒåŠ è½½çŠ¶æ€
const imageCache = new Map();

// è·å–å›¾ç‰‡URL
function getImageUrl(itemIndex, imageType) {
  const imageNumber = itemIndex + 1;
  const imageTypeMap = {
    'product': 1,
    'scene1': 2,
    'scene2': 3
  };
  
  return `${IMG_BASE_PATH}${imageNumber}_${imageTypeMap[imageType]}.jpg`;
}

// è·å–ç¼“å­˜é”®
function getCacheKey(itemIndex, imageType) {
  return `${itemIndex}_${imageType}`;
}

// æ™ºèƒ½é¢„åŠ è½½å›¾ç‰‡
async function smartPreloadImage(itemIndex, imageType) {
  const cacheKey = getCacheKey(itemIndex, imageType);
  
  // å¦‚æœå·²ç»åœ¨ç¼“å­˜ä¸­ï¼Œç›´æ¥è¿”å›
  if (imageCache.has(cacheKey)) {
    return imageCache.get(cacheKey);
  }
  
  const url = getImageUrl(itemIndex, imageType);
  
  // åˆ›å»ºåŠ è½½Promise
  const loadPromise = new Promise((resolve, reject) => {
    const img = new Image();
    
    img.onload = () => {
      // ä½¿ç”¨createImageBitmapæ¥è·å–æ›´å¿«çš„æ¸²æŸ“æ€§èƒ½
      if (typeof createImageBitmap === 'function') {
        createImageBitmap(img)
          .then(bitmap => {
            imageCache.set(cacheKey, {
              src: url,
              element: img,
              bitmap: bitmap,
              loaded: true
            });
            resolve(url);
          })
          .catch(() => {
            // fallback
            imageCache.set(cacheKey, {
              src: url,
              element: img,
              loaded: true
            });
            resolve(url);
          });
      } else {
        imageCache.set(cacheKey, {
          src: url,
          element: img,
          loaded: true
        });
        resolve(url);
      }
    };
    
    img.onerror = (error) => {
      console.warn(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${url}`, error);
      imageCache.set(cacheKey, {
        src: null,
        loaded: false,
        error: true
      });
      reject(new Error(`Failed to load image: ${url}`));
    };
    
    // è®¾ç½®crossOriginé¿å…ç¼“å­˜é—®é¢˜
    img.crossOrigin = 'anonymous';
    img.src = url;
    
    // è®¾ç½®è¶…æ—¶ï¼ˆ5ç§’ï¼‰
    setTimeout(() => {
      if (!img.complete) {
        console.warn(`å›¾ç‰‡åŠ è½½è¶…æ—¶: ${url}`);
        img.onerror = null;
        img.onload = null;
        reject(new Error(`Image load timeout: ${url}`));
      }
    }, 5000);
  });
  
  return loadPromise;
}

// ç«‹å³æ˜¾ç¤ºç¼“å­˜çš„å›¾ç‰‡
function displayCachedImage(imgElement, cacheKey) {
  if (imageCache.has(cacheKey)) {
    const cacheItem = imageCache.get(cacheKey);
    if (cacheItem.loaded && cacheItem.element) {
      // ç«‹å³ä½¿ç”¨ç¼“å­˜çš„Imageå¯¹è±¡
      imgElement.src = cacheItem.element.src;
      imgElement.style.opacity = '0';
      
      // ä½¿ç”¨requestAnimationFrameç¡®ä¿DOMæ›´æ–°
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          imgElement.style.opacity = '1';
          imgElement.style.transition = 'opacity 0.2s ease';
        });
      });
      
      return true;
    }
  }
  return false;
}

// é¢„åŠ è½½å¤šä¸ªå›¾ç‰‡
async function preloadMultipleImages(itemIndices) {
  const promises = [];
  
  for (const index of itemIndices) {
    if (index >= 0 && index < ITEMS.length) {
      ['product', 'scene1', 'scene2'].forEach(type => {
        const cacheKey = getCacheKey(index, type);
        if (!imageCache.has(cacheKey)) {
          promises.push(smartPreloadImage(index, type).catch(() => {}));
        }
      });
    }
  }
  
  // é™åˆ¶å¹¶å‘æ•°é‡ï¼Œé¿å…é˜»å¡
  const batchSize = 3;
  for (let i = 0; i < promises.length; i += batchSize) {
    const batch = promises.slice(i, i + batchSize);
    await Promise.allSettled(batch);
    // ç»™æµè§ˆå™¨å–˜æ¯çš„æœºä¼š
    await new Promise(resolve => setTimeout(resolve, 50));
  }
}

// ç”Ÿæˆ SVG å ä½å›¾ dataURL
function makePlaceholder(text, w=900, h=540, bg='%23f3f4f6', fg='%23888'){
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}"><rect width="100%" height="100%" fill="${bg}"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="Arial,Helvetica,sans-serif" font-size="20" fill="${fg}">${text}</text></svg>`;
  return 'data:image/svg+xml,' + svg;
}

const tabs = document.getElementById('tabs');
const detailPic = document.getElementById('detail-pic').querySelector('img');
const detailTitle = document.getElementById('detail-title');
const detailSub = document.getElementById('detail-sub');
const detailFormula = document.getElementById('detail-formula');
const detailScene1 = document.getElementById('detail-scene1');
const detailScene2 = document.getElementById('detail-scene2');
const detailScene1Text = document.getElementById('detail-scene1-text');
const detailScene2Text = document.getElementById('detail-scene2-text');
const mainLoading = document.getElementById('main-loading');

// æ˜¾ç¤ºåŠ è½½çŠ¶æ€
function showLoading() {
  detailPic.classList.add('loading');
  detailScene1.classList.add('loading');
  detailScene2.classList.add('loading');
  mainLoading.style.display = 'block';
}

// éšè—åŠ è½½çŠ¶æ€
function hideLoading() {
  detailPic.classList.remove('loading');
  detailScene1.classList.remove('loading');
  detailScene2.classList.remove('loading');
  mainLoading.style.display = 'none';
}

// æ™ºèƒ½é¢„åŠ è½½ç›¸é‚»é€‰é¡¹
function preloadAdjacentImages(currentIndex) {
  const indicesToPreload = [];
  
  // é¢„åŠ è½½å½“å‰ã€å‰åå„2ä¸ª
  for (let i = Math.max(0, currentIndex - 2); i <= Math.min(ITEMS.length - 1, currentIndex + 2); i++) {
    indicesToPreload.push(i);
  }
  
  // å¼‚æ­¥é¢„åŠ è½½ï¼Œä¸é˜»å¡UI
  setTimeout(() => {
    preloadMultipleImages(indicesToPreload).catch(() => {});
  }, 100);
}

// é«˜æ€§èƒ½å›¾ç‰‡åˆ‡æ¢å‡½æ•°
async function switchToItem(itemIndex) {
  const it = ITEMS[itemIndex];
  if (!it) return;
  
  // 1. ç«‹å³æ›´æ–°æ–‡å­—å†…å®¹
  detailTitle.textContent = it.title;
  detailSub.textContent = it.sub;
  detailFormula.textContent = it.formula;
  detailScene1Text.textContent = it.scene1Text || 'â€”';
  detailScene2Text.textContent = it.scene2Text || 'â€”';
  
  // 2. æ£€æŸ¥ç¼“å­˜å¹¶ç«‹å³æ˜¾ç¤º
  const imagePromises = [];
  const displayPromises = [];
  
  // å°è¯•ç«‹å³æ˜¾ç¤ºç¼“å­˜çš„å›¾ç‰‡
  const cacheKeys = [
    { key: getCacheKey(itemIndex, 'product'), element: detailPic, alt: it.title + ' äº§å“å›¾' },
    { key: getCacheKey(itemIndex, 'scene1'), element: detailScene1, alt: it.title + ' åœºæ™¯1' },
    { key: getCacheKey(itemIndex, 'scene2'), element: detailScene2, alt: it.title + ' åœºæ™¯2' }
  ];
  
  let allCached = true;
  
  cacheKeys.forEach(({ key, element, alt }) => {
    element.alt = alt;
    
    if (displayCachedImage(element, key)) {
      // å›¾ç‰‡å·²ç¼“å­˜ï¼Œç«‹å³æ˜¾ç¤º
      displayPromises.push(Promise.resolve());
    } else {
      // éœ€è¦åŠ è½½æ–°å›¾ç‰‡
      allCached = false;
      showLoading();
      
      const loadPromise = smartPreloadImage(itemIndex, key.split('_')[1])
        .then(() => {
          // åŠ è½½å®Œæˆåæ˜¾ç¤º
          displayCachedImage(element, key);
        })
        .catch(() => {
          // åŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºå ä½å›¾
          element.src = makePlaceholder(alt);
          element.style.opacity = '1';
        });
      
      imagePromises.push(loadPromise);
    }
  });
  
  // å¦‚æœæ‰€æœ‰å›¾ç‰‡éƒ½å·²ç¼“å­˜ï¼Œç«‹å³éšè—åŠ è½½çŠ¶æ€
  if (allCached) {
    hideLoading();
  }
  
  // ç­‰å¾…æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæˆ
  await Promise.allSettled([...imagePromises, ...displayPromises]);
  
  // ç¡®ä¿åŠ è½½çŠ¶æ€è¢«éšè—
  hideLoading();
  
  // 3. é¢„åŠ è½½ç›¸é‚»å›¾ç‰‡
  preloadAdjacentImages(itemIndex);
}

function renderTabs(){
  tabs.innerHTML = '';
  ITEMS.forEach((it,idx)=>{
    const el = document.createElement('button');
    el.type = 'button';
    el.className = 'tab' + (idx===0 ? ' active' : '');
    el.dataset.id = it.id;
    el.dataset.index = idx;
    el.setAttribute('aria-pressed', idx===0 ? 'true' : 'false');
    el.innerHTML = `<span class="icon" aria-hidden="true">${it.icon}</span><span>${it.title}</span>`;
    
    // æ·»åŠ è§¦æ‘¸å’Œæ‚¬åœé¢„åŠ è½½
    const preloadHandler = () => {
      const hoverIndex = parseInt(el.dataset.index);
      if (!isNaN(hoverIndex)) {
        preloadAdjacentImages(hoverIndex);
      }
    };
    
    el.addEventListener('mouseenter', preloadHandler);
    el.addEventListener('touchstart', preloadHandler, { passive: true });
    
    el.addEventListener('click', async () => {
      // æ›´æ–°æ¿€æ´»çŠ¶æ€
      document.querySelectorAll('.tab').forEach(t => {
        t.classList.remove('active');
        t.setAttribute('aria-pressed', 'false');
      });
      el.classList.add('active');
      el.setAttribute('aria-pressed', 'true');
      
      // åˆ‡æ¢å†…å®¹
      await switchToItem(idx);
    });
    
    tabs.appendChild(el);
  });
}

// å¤åˆ¶æŒ‰é’®
document.getElementById('btn-copy').addEventListener('click', () => {
  const text = `${detailTitle.textContent}
${detailSub.textContent}
é…æ–¹ï¼š${detailFormula.textContent}`;
  
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text)
      .then(() => alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'))
      .catch(() => fallbackCopy(text));
  } else {
    fallbackCopy(text);
  }
});

function fallbackCopy(text){
  const ta = document.createElement('textarea'); 
  ta.value = text; 
  document.body.appendChild(ta); 
  ta.select();
  try{ 
    document.execCommand('copy'); 
    alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'); 
  }catch(e){ 
    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶:\n'+text); 
  }
  ta.remove();
}

// åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', async function() {
  renderTabs();
  
  // ç«‹å³é¢„åŠ è½½ç¬¬ä¸€ä¸ªé€‰é¡¹çš„å›¾ç‰‡
  await preloadMultipleImages([0, 1, 2]);
  
  // è®¾ç½®ç¬¬ä¸€ä¸ªæ ‡ç­¾ä¸ºæ¿€æ´»çŠ¶æ€å¹¶æ˜¾ç¤º
  const firstTab = document.querySelector('.tab');
  if (firstTab) {
    firstTab.click();
  }
  
  // ç©ºé—²æ—¶é¢„åŠ è½½æ‰€æœ‰å›¾ç‰‡
  if ('requestIdleCallback' in window) {
    window.requestIdleCallback(() => {
      const allIndices = ITEMS.map((_, idx) => idx);
      preloadMultipleImages(allIndices).catch(() => {});
    }, { timeout: 3000 });
  } else {
    setTimeout(() => {
      const allIndices = ITEMS.map((_, idx) => idx);
      preloadMultipleImages(allIndices).catch(() => {});
    }, 3000);
  }
});

// åœ¨ ITEMS å®šä¹‰ä¹‹åï¼Œæ·»åŠ ä»¥ä¸‹ä»£ç 

// æ”¹è¿›çš„ç¼“å­˜ç®¡ç†å™¨
class ImageCacheManager {
  constructor() {
    this.memoryCache = new Map();
    this.loadingPromises = new Map();
    this.prefetchQueue = [];
  }

  // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦å·²ç¼“å­˜ï¼ˆå†…å­˜æˆ–æµè§ˆå™¨ï¼‰
  async isImageCached(url) {
    // 1. é¦–å…ˆæ£€æŸ¥å†…å­˜ç¼“å­˜
    if (this.memoryCache.has(url) && this.memoryCache.get(url).loaded) {
      return true;
    }
    
    // 2. æ£€æŸ¥æµè§ˆå™¨ç¼“å­˜ï¼ˆä½¿ç”¨ fetch API æ£€æŸ¥ç¼“å­˜ï¼‰
    try {
      const cached = await this.checkBrowserCache(url);
      return cached;
    } catch (e) {
      return false;
    }
  }

  // æ£€æŸ¥æµè§ˆå™¨ç¼“å­˜
  async checkBrowserCache(url) {
    try {
      const cache = await caches.open('tcm-images');
      const response = await cache.match(url);
      return !!response;
    } catch (e) {
      // å¦‚æœ Cache API ä¸å¯ç”¨ï¼Œå°è¯•å…¶ä»–æ–¹æ³•
      return this.checkImageCacheFallback(url);
    }
  }

  // å›é€€æ–¹æ³•æ£€æŸ¥å›¾ç‰‡ç¼“å­˜
  async checkImageCacheFallback(url) {
    return new Promise((resolve) => {
      const img = new Image();
      img.src = url;
      
      // è®¾ç½®ä¸€ä¸ªæ ‡å¿—ï¼Œå¦‚æœå›¾ç‰‡å¾ˆå¿«åŠ è½½å®Œæˆï¼Œè¯´æ˜æœ‰ç¼“å­˜
      let cacheChecked = false;
      
      img.onload = () => {
        if (!cacheChecked) {
          resolve(true);
        }
      };
      
      img.onerror = () => {
        resolve(false);
      };
      
      // è®¾ç½®ä¸€ä¸ªè¶…æ—¶æ—¶é—´ï¼Œå¦‚æœå›¾ç‰‡åœ¨çŸ­æ—¶é—´å†…åŠ è½½å®Œæˆï¼Œè¯´æ˜æœ‰ç¼“å­˜
      setTimeout(() => {
        cacheChecked = true;
        resolve(img.complete);
      }, 50);
    });
  }

  // æ™ºèƒ½åŠ è½½å›¾ç‰‡ï¼ˆä¼˜å…ˆä½¿ç”¨ç¼“å­˜ï¼‰
  async loadImage(url, alt) {
    const cacheKey = url;
    
    // å¦‚æœå·²ç»åœ¨åŠ è½½ä¸­ï¼Œè¿”å›è¯¥ Promise
    if (this.loadingPromises.has(cacheKey)) {
      return this.loadingPromises.get(cacheKey);
    }
    
    // åˆ›å»ºåŠ è½½ Promise
    const loadPromise = new Promise(async (resolve, reject) => {
      try {
        // é¦–å…ˆæ£€æŸ¥æ˜¯å¦å·²ç¼“å­˜
        const isCached = await this.isImageCached(url);
        
        if (isCached) {
          // ä»ç¼“å­˜å¿«é€ŸåŠ è½½
          const img = new Image();
          img.onload = () => {
            this.memoryCache.set(cacheKey, {
              src: url,
              element: img,
              loaded: true,
              cached: true
            });
            resolve({ img, cached: true });
          };
          img.src = url;
        } else {
          // éœ€è¦ç½‘ç»œåŠ è½½
          const img = new Image();
          img.onload = () => {
            this.memoryCache.set(cacheKey, {
              src: url,
              element: img,
              loaded: true,
              cached: false
            });
            resolve({ img, cached: false });
          };
          img.onerror = reject;
          img.crossOrigin = 'anonymous';
          img.src = url;
          
          // è®¾ç½®è¶…æ—¶
          setTimeout(() => {
            if (!img.complete) {
              reject(new Error('Image load timeout'));
            }
          }, 3000);
        }
      } catch (error) {
        reject(error);
      }
    });
    
    // ä¿å­˜ Promise
    this.loadingPromises.set(cacheKey, loadPromise);
    
    // æ¸…ç† Promiseï¼ˆ10åˆ†é’Ÿåï¼‰
    setTimeout(() => {
      this.loadingPromises.delete(cacheKey);
    }, 10 * 60 * 1000);
    
    return loadPromise;
  }

  // é¢„åŠ è½½å›¾ç‰‡
  async prefetchImage(url) {
    if (await this.isImageCached(url)) {
      return true;
    }
    
    return this.loadImage(url, 'prefetch').then(() => true).catch(() => false);
  }

  // æ‰¹é‡é¢„åŠ è½½
  async prefetchBatch(urls) {
    const results = [];
    const batchSize = 2; // å‡å°æ‰¹é‡å¤§å°ï¼Œé¿å…é˜»å¡
    
    for (let i = 0; i < urls.length; i += batchSize) {
      const batch = urls.slice(i, i + batchSize);
      const batchResults = await Promise.allSettled(
        batch.map(url => this.prefetchImage(url))
      );
      results.push(...batchResults);
      
      // ç»™æµè§ˆå™¨å–˜æ¯æ—¶é—´
      if (i + batchSize < urls.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    return results;
  }
}

// åˆ›å»ºç¼“å­˜ç®¡ç†å™¨å®ä¾‹
const cacheManager = new ImageCacheManager();

// ä¿®æ”¹ getImageUrl å‡½æ•°ï¼Œä½¿å…¶è¿”å›å®Œæ•´ URL
function getImageUrl(itemIndex, imageType) {
  const imageNumber = itemIndex + 1;
  const imageTypeMap = {
    'product': 1,
    'scene1': 2,
    'scene2': 3
  };
  
  return `${IMG_BASE_PATH}${imageNumber}_${imageTypeMap[imageType]}.jpg`;
}

// ä¿®æ”¹æ˜¾ç¤ºç¼“å­˜çš„å›¾ç‰‡å‡½æ•°
async function displayImage(imgElement, url, alt) {
  imgElement.alt = alt;
  
  try {
    // å°è¯•å¿«é€Ÿä»ç¼“å­˜åŠ è½½
    const { img, cached } = await cacheManager.loadImage(url, alt);
    
    // ç«‹å³è®¾ç½®å›¾ç‰‡æº
    imgElement.src = img.src;
    
    // å¦‚æœæ˜¯ç¼“å­˜çš„ï¼Œç«‹å³æ˜¾ç¤ºï¼Œå¦åˆ™æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
    if (cached) {
      imgElement.style.opacity = '1';
      imgElement.classList.remove('loading');
    } else {
      imgElement.classList.add('loading');
      img.onload = () => {
        imgElement.classList.remove('loading');
        imgElement.style.opacity = '1';
      };
    }
    
    return true;
  } catch (error) {
    console.warn(`åŠ è½½å›¾ç‰‡å¤±è´¥: ${url}`, error);
    imgElement.src = makePlaceholder(alt);
    imgElement.classList.remove('loading');
    imgElement.style.opacity = '1';
    return false;
  }
}

// ä¿®æ”¹é¢„åŠ è½½å¤šä¸ªå›¾ç‰‡å‡½æ•°
async function preloadMultipleImages(itemIndices) {
  const urls = [];
  
  for (const index of itemIndices) {
    if (index >= 0 && index < ITEMS.length) {
      ['product', 'scene1', 'scene2'].forEach(type => {
        urls.push(getImageUrl(index, type));
      });
    }
  }
  
  // å»é‡
  const uniqueUrls = [...new Set(urls)];
  
  // å¼‚æ­¥é¢„åŠ è½½ï¼Œä¸é˜»å¡UI
  setTimeout(() => {
    cacheManager.prefetchBatch(uniqueUrls).catch(() => {});
  }, 0);
}

// ä¿®æ”¹é«˜æ€§èƒ½å›¾ç‰‡åˆ‡æ¢å‡½æ•°
async function switchToItem(itemIndex) {
  const it = ITEMS[itemIndex];
  if (!it) return;
  
  // ç«‹å³æ›´æ–°æ–‡å­—å†…å®¹
  detailTitle.textContent = it.title;
  detailSub.textContent = it.sub;
  detailFormula.textContent = it.formula;
  detailScene1Text.textContent = it.scene1Text || 'â€”';
  detailScene2Text.textContent = it.scene2Text || 'â€”';
  
  // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
  showLoading();
  
  // è·å–å›¾ç‰‡URL
  const imageUrls = [
    { url: getImageUrl(itemIndex, 'product'), alt: it.title + ' äº§å“å›¾', element: detailPic },
    { url: getImageUrl(itemIndex, 'scene1'), alt: it.title + ' åœºæ™¯1', element: detailScene1 },
    { url: getImageUrl(itemIndex, 'scene2'), alt: it.title + ' åœºæ™¯2', element: detailScene2 }
  ];
  
  // å¹¶è¡ŒåŠ è½½å›¾ç‰‡
  const loadPromises = imageUrls.map(({ url, alt, element }) => 
    displayImage(element, url, alt)
  );
  
  // ç­‰å¾…æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆ
  await Promise.allSettled(loadPromises);
  
  // éšè—åŠ è½½çŠ¶æ€
  hideLoading();
  
  // é¢„åŠ è½½ç›¸é‚»å›¾ç‰‡
  setTimeout(() => {
    preloadAdjacentImages(itemIndex);
  }, 0);
}

// ä¿®æ”¹æ™ºèƒ½é¢„åŠ è½½ç›¸é‚»é€‰é¡¹
function preloadAdjacentImages(currentIndex) {
  const indicesToPreload = [];
  
  // é¢„åŠ è½½å½“å‰ã€å‰åå„2ä¸ª
  for (let i = Math.max(0, currentIndex - 2); i <= Math.min(ITEMS.length - 1, currentIndex + 2); i++) {
    indicesToPreload.push(i);
  }
  
  // å¼‚æ­¥é¢„åŠ è½½ï¼Œä¸é˜»å¡UI
  setTimeout(() => {
    preloadMultipleImages(indicesToPreload).catch(() => {});
  }, 0);
}

// ä¿®æ”¹åˆå§‹åŒ–ä»£ç 
document.addEventListener('DOMContentLoaded', async function() {
  renderTabs();
  
  // å¿«é€Ÿæ˜¾ç¤ºç¬¬ä¸€ä¸ªé¡¹ç›®
  const firstTab = document.querySelector('.tab');
  if (firstTab) {
    // ç«‹å³åˆ‡æ¢ï¼ˆä¸ç­‰å¾…é¢„åŠ è½½ï¼‰
    const index = parseInt(firstTab.dataset.index);
    const it = ITEMS[index];
    
    // ç«‹å³æ˜¾ç¤ºæ–‡å­—å†…å®¹
    detailTitle.textContent = it.title;
    detailSub.textContent = it.sub;
    detailFormula.textContent = it.formula;
    detailScene1Text.textContent = it.scene1Text || 'â€”';
    detailScene2Text.textContent = it.scene2Text || 'â€”';
    
    // æ¿€æ´»ç¬¬ä¸€ä¸ªæ ‡ç­¾
    document.querySelectorAll('.tab').forEach(t => {
      t.classList.remove('active');
      t.setAttribute('aria-pressed', 'false');
    });
    firstTab.classList.add('active');
    firstTab.setAttribute('aria-pressed', 'true');
    
    // å¼€å§‹åŠ è½½å›¾ç‰‡ï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡ï¼‰
    setTimeout(() => {
      switchToItem(index).catch(() => {});
    }, 0);
  }
  
  // ç«‹å³å¼€å§‹ç§¯æé¢„åŠ è½½
  setTimeout(() => {
    // é¦–å…ˆé¢„åŠ è½½å‰3ä¸ªé¡¹ç›®
    preloadMultipleImages([0, 1, 2]);
    
    // ç„¶åé¢„åŠ è½½æ‰€æœ‰é¡¹ç›®ï¼ˆåˆ†æ‰¹è¿›è¡Œï¼‰
    setTimeout(() => {
      const allIndices = ITEMS.map((_, idx) => idx);
      preloadMultipleImages(allIndices);
    }, 500);
    
    // æ·»åŠ ç”¨æˆ·äº¤äº’è§¦å‘çš„é¢„åŠ è½½
    let hasInteracted = false;
    const interactionHandler = () => {
      if (!hasInteracted) {
        hasInteracted = true;
        // ç”¨æˆ·ç¬¬ä¸€æ¬¡äº¤äº’æ—¶ï¼Œé¢„åŠ è½½æ‰€æœ‰å›¾ç‰‡
        const allIndices = ITEMS.map((_, idx) => idx);
        preloadMultipleImages(allIndices);
        
        // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
        document.removeEventListener('mousemove', interactionHandler);
        document.removeEventListener('touchstart', interactionHandler);
      }
    };
    
    document.addEventListener('mousemove', interactionHandler, { once: false, passive: true });
    document.addEventListener('touchstart', interactionHandler, { once: false, passive: true });
  }, 100);
});

// ä¿®æ”¹æ ‡ç­¾çš„ç‚¹å‡»äº‹ä»¶å¤„ç†
el.addEventListener('click', async (e) => {
  e.preventDefault();
  
  // æ›´æ–°æ¿€æ´»çŠ¶æ€
  document.querySelectorAll('.tab').forEach(t => {
    t.classList.remove('active');
    t.setAttribute('aria-pressed', 'false');
  });
  el.classList.add('active');
  el.setAttribute('aria-pressed', 'true');
  
  // åˆ‡æ¢å†…å®¹ï¼ˆä¸ç­‰å¾…ï¼‰
  const index = parseInt(el.dataset.index);
  setTimeout(() => {
    switchToItem(index).catch(() => {});
  }, 0);
});

// ä¿®æ”¹æ ‡ç­¾çš„æ‚¬åœäº‹ä»¶ï¼Œæ·»åŠ é˜²æŠ–
let hoverTimer = null;
el.addEventListener('mouseenter', () => {
  if (hoverTimer) clearTimeout(hoverTimer);
  
  hoverTimer = setTimeout(() => {
    const hoverIndex = parseInt(el.dataset.index);
    if (!isNaN(hoverIndex)) {
      preloadAdjacentImages(hoverIndex);
    }
    hoverTimer = null;
  }, 100); // 100ms é˜²æŠ–
});

el.addEventListener('mouseleave', () => {
  if (hoverTimer) {
    clearTimeout(hoverTimer);
    hoverTimer = null;
  }
});
</script>
</body>
</html>