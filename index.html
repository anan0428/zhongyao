<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ä¸­è¯é…æ–¹</title>
  <style>
    :root{--bg:#f6f8fb;--card:#ffffff;--muted:#6b7280;--accent:#7c3aed;--radius:12px}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;background:#f8fafc}
    .app{padding:14px;max-width:540px;margin:auto}

    header{margin-bottom:10px}
    h1{font-size:18px;margin:0 0 4px 0}
    p.lead{margin:0;color:var(--muted);font-size:13px}

    /* ä¸¤è¡Œå¸¦å›¾æ ‡æ ‡ç­¾ */
    .tabs{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
    .tab{background:var(--card);padding:6px 10px 6px 8px;border-radius:20px;font-size:13px;border:1px solid transparent;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,0.06);display:flex;align-items:center;gap:8px;min-height:40px}
    .tab .icon{font-size:18px;line-height:1;flex-shrink:0}
    .tab span{display:inline-block;max-width:120px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}
    .tab.active{border-color:var(--accent);color:var(--accent);font-weight:600}

    /* ä¸»å†…å®¹å¡ç‰‡ */
    .card-main{background:var(--card);border-radius:var(--radius);padding:14px;margin-top:10px;box-shadow:0 8px 20px rgba(0,0,0,0.06)}
    .hero{display:flex;gap:12px;align-items:flex-start}
    .hero .pic{width:140px;height:140px;border-radius:10px;overflow:hidden;background:#eee;flex-shrink:0;position:relative}
    .hero img{width:100%;height:100%;object-fit:cover;display:block;transition:opacity 0.22s ease}
    .hero img.loading{opacity:0.4}
    h2{margin:0;font-size:17px}
    .meta{font-size:13px;color:var(--muted);margin-top:4px}

    .section{margin-top:12px}
    .label{font-size:13px;color:var(--muted);margin-bottom:6px}
    .box{background:#fdfefe;padding:10px;border-radius:10px;font-size:14px;border:1px solid rgba(0,0,0,0.04)}

    .scene-img{width:100%;height:180px;object-fit:cover;border-radius:8px;background:#f3f4f6;display:block;transition:opacity 0.22s ease}
    .scene-img.loading{opacity:0.4}
    .scene-text{margin-top:8px;color:var(--muted);font-size:14px}

    footer{margin-top:14px;display:flex;gap:10px}
    .btn{flex:1;padding:10px;border:0;border-radius:10px;font-weight:600;background:var(--accent);color:#fff}

    /* åŠ è½½åŠ¨ç”» */
    .loading-shimmer {position: absolute;top: 0;left: 0;width: 100%;height: 100%;background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 50%, rgba(255,255,255,0) 100%);background-size: 200% 100%;animation: shimmer 1.5s infinite;border-radius: inherit}
    @keyframes shimmer {0% { background-position: -200% 0; }100% { background-position: 200% 0; }}
    @media (max-width:420px){.tab span{max-width:90px}.hero .pic{width:110px;height:110px}.scene-img{height:120px}}

    /* å…¨å±é¢„åŠ è½½é®ç½©ï¼ˆè¿›åº¦æ¡ï¼‰ */
    #preloader{position:fixed;inset:0;background:linear-gradient(180deg, rgba(255,255,255,0.96), rgba(250,250,250,0.98));display:flex;align-items:center;justify-content:center;z-index:9999;flex-direction:column;padding:20px}
    .preloader-card{max-width:420px;width:100%;text-align:center}
    .preloader-title{font-size:20px;margin-bottom:8px;color:#111}
    .preloader-sub{font-size:13px;color:var(--muted);margin-bottom:16px}
    .progress-wrap{background:#eef2ff;border-radius:12px;padding:6px}
    .progress-bar{height:12px;border-radius:8px;background:linear-gradient(90deg,var(--accent),#5b21b6);width:0%;transition:width 200ms linear}
    .progress-percent{margin-top:8px;font-size:13px;color:var(--muted)}
    .preloader-spinner{margin-top:12px;border:4px solid rgba(0,0,0,0.06);border-top-color:var(--accent);border-radius:50%;width:36px;height:36px;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
<!-- å…¨å±é¢„åŠ è½½é®ç½© -->
<div id="preloader" aria-hidden="false">
  <div class="preloader-card" role="status" aria-live="polite">
    <div class="preloader-title">æ­£åœ¨å‡†å¤‡é¡µé¢â€¦</div>
    <div class="preloader-sub">loading</div>
    <div class="progress-wrap">
      <div id="progressBar" class="progress-bar" style="width:0%"></div>
    </div>
    <div id="progressPercent" class="progress-percent">0%</div>
    <div class="preloader-spinner" aria-hidden="true"></div>
  </div>
</div>

<div class="app" id="appContent" style="visibility:hidden;">
  <header>
    <h1>ä¸­è¯é…æ–¹é€ŸæŸ¥</h1>
    <p class="lead"></p>
  </header>

  <!-- ä¸¤è¡Œå›¾æ ‡æ ‡ç­¾æ  -->
  <div class="tabs" id="tabs" aria-label="é…æ–¹åˆ†ç±»"></div>

  <div class="card-main" role="region" aria-live="polite">
    <div class="hero">
      <div class="pic" id="detail-pic">
        <img src="" alt="äº§å“å›¾å ä½" decoding="async">
        <div class="loading-shimmer" style="display:none" id="main-loading"></div>
      </div>
      <div style="flex:1">
        <h2 id="detail-title">è¯·é€‰æ‹©é¡¹ç›®</h2>
        <div class="meta" id="detail-sub">é€‰æ‹©ä¸Šæ–¹ä»»ä¸€æ ‡ç­¾æŸ¥çœ‹è¯¦æƒ…</div>
      </div>
    </div>

    <div class="section">
      <div class="label">é…æ–¹</div>
      <div class="box" id="detail-formula">â€”</div>
    </div>

    <!-- åœºæ™¯ä¸€ï¼ˆç‹¬å ä¸€è¡Œï¼‰ -->
    <div class="section">
      <div class="label">ä½¿ç”¨åœºæ™¯ 1</div>
      <div class="box">
        <img src="" alt="åœºæ™¯1å ä½å›¾" id="detail-scene1" class="scene-img" decoding="async">
        <div id="detail-scene1-text" class="scene-text">â€”</div>
      </div>
    </div>

    <!-- åœºæ™¯äºŒï¼ˆç‹¬å ä¸€è¡Œï¼‰ -->
    <div class="section">
      <div class="label">ä½¿ç”¨åœºæ™¯ 2</div>
      <div class="box">
        <img src="" alt="åœºæ™¯2å ä½å›¾" id="detail-scene2" class="scene-img" decoding="async">
        <div id="detail-scene2-text" class="scene-text">â€”</div>
      </div>
    </div>

    <footer>
      <button class="btn" id="btn-copy">å¤åˆ¶é…æ–¹</button>
    </footer>
  </div>
</div>

<script>
/* ------------------ æ•°æ® ------------------ */
const ITEMS = [
  {id:'insomnia', title:'å®‰ç¥åŠ©çœ æ¬¾', icon:'ğŸŒ™', sub:'å¤±çœ /å‹åŠ›å¤§', scene1Text:'é…’åº—å®¢æˆ¿é¤', scene2Text:'æ·±å¤œä¾¿åˆ©åº—', formula:'é¢ç²‰+é…¸æ£ä»+èŒ¯è‹“+è¿œå¿—'},
  {id:'children', title:'å¥è„¾æ¶ˆç§¯æ¬¾', icon:'ğŸ§’', sub:'å„¿ç«¥/ç§¯é£Ÿäººç¾¤', scene1Text:'äº²å­é¤å…', scene2Text:'å¹¼å„¿å›­é…é¤', formula:'é¢ç²‰+é¸¡å†…é‡‘+éº¦èŠ½+å±±æ¥‚'},
  {id:'cold', title:'å¾¡å¯’æš–èº«æ¬¾', icon:'â„ï¸', sub:'ç•å¯’/ä½æ¸©', scene1Text:'ç«é”…åº—é™„é¤', scene2Text:'ç¤¾åŒºæ—©é¤è½¦', formula:'é¢ç²‰+ç”Ÿå§œ+çº¢ç³–+è‚‰'},
  {id:'anxiety', title:'ç–è‚ç†æ°”æ¬¾', icon:'ğŸ§­', sub:'ç„¦è™‘/è‚æ°”éƒç»“', scene1Text:'èŒåœºè½»é£Ÿåº—', scene2Text:'å¿ƒç†å’¨è¯¢å®¤é…å¥—é¤', formula:'é¢ç²‰+ä½›æ‰‹+é¦™æ©¼+é™ˆçš®'},
  {id:'fatigue', title:'ç›Šè‚¾å›ºç²¾æ¬¾', icon:'âš¡', sub:'ç†¬å¤œè‚¾è™š/ç²¾åŠ›ä¸è¶³', scene1Text:'ç”·å£«å…»ç”Ÿä¼šæ‰€', scene2Text:'ç”µç«é…’åº—é¤é£Ÿ', formula:'é¢ç²‰+èŠ¡å®+è²å­+å±±è¯'},
  {id:'throat', title:'æ¸…å’½æ¶¦å–‰æ¬¾', icon:'ğŸ¤', sub:'ç”¨å—“è¿‡åº¦/å’½å–‰ä¸é€‚', scene1Text:'KTVé…å¥—é¤', scene2Text:'æ•™å¸ˆé£Ÿå ‚', formula:'é¢ç²‰+ç½—æ±‰æœ+æ¡”æ¢—+ç™¾åˆ'},
  {id:'water', title:'æ¶ˆè„‚æ’æµŠæ¬¾', icon:'ğŸ’§', sub:'ä¹…åæ°´è‚¿/ä»£è°¢ç¼“æ…¢', scene1Text:'ç‘œä¼½é¦†è½»é£ŸåŒº', scene2Text:'é€šå‹¤ä¾¿åˆ©åº—', formula:'é¢ç²‰+å†³æ˜å­+èŒ¯è‹“+å†¬ç“œ'},
  {id:'stomach', title:'æ¸©èƒƒæ•£å¯’æ¬¾', icon:'ğŸœ', sub:'èƒƒå¯’/ç§‹å†¬èƒƒç—›', scene1Text:'åŒ—æ–¹æ—©é¤æ‘Š', scene2Text:'ç¤¾åŒºä¾¿æ°‘é£Ÿå ‚', formula:'é¢ç²‰+å°èŒ´é¦™+å¹²å§œ+èƒ¡æ¤’'}
];
const IMG_BASE_PATH = './img/';
function getImageUrl(itemIndex, imageType){
  const imageNumber = itemIndex + 1;
  const imageTypeMap = {'product':1,'scene1':2,'scene2':3};
  return `${IMG_BASE_PATH}${imageNumber}_${imageTypeMap[imageType]}.jpg`;
}
function getCacheKey(itemIndex, imageType){ return `${itemIndex}_${imageType}`; }

/* ------------------ é«˜çº§åŠ è½½å™¨ï¼ˆæ”¹è¿›ç‚¹ï¼‰ ------------------
   - å»é‡ï¼šæ­£åœ¨åŠ è½½çš„ key ä¼šä¿å­˜ä¸€ä¸ª loadingPromiseï¼Œé¿å…é‡å¤è¯·æ±‚
   - ä¼˜å…ˆçº§ï¼šç‚¹å‡»åŠ è½½ä¼šæ”¾å…¥é˜Ÿåˆ—å‰é¢ï¼ˆpriority = trueï¼‰
   - å¹¶å‘ï¼šå¯è°ƒçš„ MAX_CONCURRENCY
   - æ›´å¿«å›é€€ï¼šä½è´¨é‡å ä½å›¾ + æ¸æ˜¾
   - fetch ä½¿ç”¨ 'force-cache' ä»¥æ›´å¥½é‡ç”¨æµè§ˆå™¨ç¼“å­˜ï¼ˆå¯¹å·²éƒ¨ç½²é¡µé¢æœ‰ç”¨ï¼‰
*/
const imageCache = new Map(); // key -> {src, blob, loaded, error, loadingPromise}
const controllers = new Map(); // key -> AbortController (å¯ç”¨äºå–æ¶ˆ)
let MAX_CONCURRENCY = 6; // é€‚å½“æé«˜ä»¥åˆ©ç”¨http/2æˆ–æœ¬åœ°ç½‘ç»œ
let currentConcurrency = 0;
const queue = []; // {fn,resolve,reject,priority}

function enqueueLoad(taskFn, priority=false){
  return new Promise((resolve,reject)=>{
    const job = {fn:taskFn, resolve, reject, priority};
    if (priority) queue.unshift(job); else queue.push(job);
    processQueue();
  });
}

function processQueue(){
  if (!queue.length) return;
  if (currentConcurrency >= MAX_CONCURRENCY) return;
  const job = queue.shift();
  currentConcurrency++;
  job.fn().then(res=>{ currentConcurrency--; job.resolve(res); processQueue(); }).catch(err=>{ currentConcurrency--; job.reject(err); processQueue(); });
}

async function fetchAndDecodeImage(url, timeoutMs=9000, key=null){
  // å¦‚æœå·²æœ‰ controllerï¼Œå¤ç”¨æˆ–è¦†ç›–
  const controller = new AbortController();
  if (key) controllers.set(key, controller);
  const id = setTimeout(()=> controller.abort(), timeoutMs);
  try{
    // æ›´å‹å¥½çš„ cache ç­–ç•¥ï¼ˆå¯é…ç½®ï¼‰
    const resp = await fetch(url, {signal: controller.signal, cache: 'force-cache'});
    if (!resp.ok) throw new Error('ç½‘ç»œé”™è¯¯ ' + resp.status);
    const blob = await resp.blob();
    // å°è¯• createImageBitmap åŠ é€Ÿè§£ç 
    if (typeof createImageBitmap === 'function'){
      try{
        const bitmap = await createImageBitmap(blob);
        clearTimeout(id);
        return {blob, bitmap};
      }catch(e){ clearTimeout(id); return {blob, bitmap:null}; }
    }
    clearTimeout(id);
    return {blob, bitmap:null};
  }catch(err){ clearTimeout(id); throw err; }
}

function smartLoadImage(itemIndex, imageType, {priority=false} = {}){
  const key = getCacheKey(itemIndex, imageType);
  const existing = imageCache.get(key);
  if (existing){
    // å¦‚æœå·²åŠ è½½ï¼Œç›´æ¥è¿”å›
    if (existing.loaded) return Promise.resolve(existing);
    // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œè¿”å›å®ƒçš„ promise
    if (existing.loadingPromise) return existing.loadingPromise;
  }

  // åˆ›å»ºåŠ è½½ä»»åŠ¡å¹¶æŠŠ loadingPromise å­˜å…¥ cacheï¼ˆé¿å…é‡å¤ï¼‰
  const url = getImageUrl(itemIndex, imageType);
  const task = async ()=>{
    try{
      const {blob, bitmap} = await fetchAndDecodeImage(url, 9000, key);
      const objectUrl = URL.createObjectURL(blob);
      const item = {src: objectUrl, blob, bitmap, loaded:true, url};
      imageCache.set(key, item);
      controllers.delete(key);
      return item;
    }catch(err){
      const item = {src:null, loaded:false, error:true, url};
      imageCache.set(key, item);
      controllers.delete(key);
      throw err;
    }
  };

  const promise = enqueueLoad(task, priority).then(res=>res).catch(err=>{ throw err; });
  imageCache.set(key, {loadingPromise: promise});
  return promise;
}

function displayCachedImage(imgEl, key, alt){
  const entry = imageCache.get(key);
  if (entry && entry.loaded && entry.src){
    imgEl.src = entry.src;
    imgEl.alt = alt || imgEl.alt;
    imgEl.style.opacity = '0';
    requestAnimationFrame(()=> requestAnimationFrame(()=>{ imgEl.style.opacity='1'; imgEl.style.transition='opacity 0.18s ease'; }));
    return true;
  }
  return false;
}

function makeSmallPlaceholder(text){
  // æ›´å°çš„ SVG å ä½ä»¥å‡å°‘åˆ‡æ¢æ—¶ç™½å±
  const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"300\" height=\"180\"><rect width=\"100%\" height=\"100%\" fill=\"%23f3f4f6\"/><text x=\"50%\" y=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\" font-family=\"Arial,Helvetica,sans-serif\" font-size=\"14\" fill=\"%23888\">${text}</text></svg>`;
  return 'data:image/svg+xml,' + encodeURIComponent(svg);
}

/* ------------------ UI & é¢„åŠ è½½ç­–ç•¥ ------------------ */
const tabs = document.getElementById('tabs');
const detailPic = document.getElementById('detail-pic').querySelector('img');
const detailTitle = document.getElementById('detail-title');
const detailSub = document.getElementById('detail-sub');
const detailFormula = document.getElementById('detail-formula');
const detailScene1 = document.getElementById('detail-scene1');
const detailScene2 = document.getElementById('detail-scene2');
const detailScene1Text = document.getElementById('detail-scene1-text');
const detailScene2Text = document.getElementById('detail-scene2-text');
const mainLoading = document.getElementById('main-loading');
const preloader = document.getElementById('preloader');
const progressBar = document.getElementById('progressBar');
const progressPercent = document.getElementById('progressPercent');

function showLoading(){ mainLoading.style.display='block'; detailPic.classList.add('loading'); detailScene1.classList.add('loading'); detailScene2.classList.add('loading'); }
function hideLoading(){ mainLoading.style.display='none'; detailPic.classList.remove('loading'); detailScene1.classList.remove('loading'); detailScene2.classList.remove('loading'); }

async function preloadInitialWithProgress(indices, onProgress, timeout=12000){
  const keys = [];
  indices.forEach(index=>{ if (index>=0 && index<ITEMS.length){ ['product','scene1','scene2'].forEach(type=>keys.push({index,type})); } });
  let completed = 0; const total = keys.length;
  const trackers = keys.map(({index,type})=>{
    const key = getCacheKey(index,type);
    if (imageCache.has(key) && imageCache.get(key).loaded){ completed++; onProgress(Math.round((completed/total)*100)); return Promise.resolve(); }
    // ä¼˜å…ˆçº§ï¼šä¸»å›¾æ›´é«˜ï¼Œè¿™é‡Œä¸ç»™æ¯ä¸ªä¸åŒä¼˜å…ˆçº§ï¼Œä½†åœ¨ switch æ—¶ä¼šä½¿ç”¨ priority=true
    return smartLoadImage(index,type,{priority:false}).then(()=>{ completed++; onProgress(Math.round((completed/total)*100)); }).catch(()=>{ completed++; onProgress(Math.round((completed/total)*100)); });
  });

  const allSettled = Promise.allSettled(trackers);
  const timer = new Promise((resolve)=> setTimeout(resolve, timeout, 'timeout'));
  return Promise.race([allSettled, timer]).then(result=> result === 'timeout' ? {timeout:true} : {timeout:false});
}

async function preloadMultipleImages(indices){
  const tasks = [];
  indices.forEach(idx=>{ if (idx>=0 && idx<ITEMS.length){ ['product','scene1','scene2'].forEach(type=>{ const key = getCacheKey(idx,type); if (!imageCache.has(key) || !imageCache.get(key).loaded) tasks.push(smartLoadImage(idx,type,{priority:false}).catch(()=>{})); }); } });
  // throttle batches
  const batch = 8;
  for (let i=0;i<tasks.length;i+=batch){ await Promise.allSettled(tasks.slice(i,i+batch)); await new Promise(r=>setTimeout(r,30)); }
}

function preloadAdjacent(currentIndex){
  const arr = [];
  for (let i=Math.max(0,currentIndex-2); i<=Math.min(ITEMS.length-1,currentIndex+2); i++) arr.push(i);
  setTimeout(()=>{ preloadMultipleImages(arr).catch(()=>{}); }, 60);
}

async function switchToItem(itemIndex){
  const it = ITEMS[itemIndex]; if(!it) return;
  detailTitle.textContent = it.title; detailSub.textContent = it.sub; detailFormula.textContent = it.formula; detailScene1Text.textContent = it.scene1Text || 'â€”'; detailScene2Text.textContent = it.scene2Text || 'â€”';

  // ä¼˜å…ˆæ˜¾ç¤ºç¼“å­˜
  const keys = [
    {k:getCacheKey(itemIndex,'product'), el:detailPic, alt:it.title+' äº§å“å›¾'},
    {k:getCacheKey(itemIndex,'scene1'), el:detailScene1, alt:it.title+' åœºæ™¯1'},
    {k:getCacheKey(itemIndex,'scene2'), el:detailScene2, alt:it.title+' åœºæ™¯2'}
  ];

  let needLoad=false;
  keys.forEach(({k,el,alt})=>{
    el.alt=alt;
    if (!displayCachedImage(el,k,alt)){
      // ç”¨å°å ä½å¿«é€Ÿå±•ç¤ºï¼Œé¿å…ç™½å±
      el.src = makeSmallPlaceholder(alt);
      el.style.opacity='1';
      needLoad=true;
    }
    if (el===detailPic){ el.loading='eager'; el.decoding='async'; }
  });
  if (needLoad) showLoading();

  // è¯·æ±‚ä¼˜å…ˆçº§ï¼šäº§å“å›¾ä¼˜å…ˆï¼ˆpriority=trueï¼‰
  const promises = keys.map(({k})=>{
    if (imageCache.has(k) && imageCache.get(k).loaded) return Promise.resolve();
    const [idx,type] = k.split('_');
    const id = parseInt(idx,10);
    const priority = type === 'product';
    return smartLoadImage(id,type,{priority}).then(item=>{
      const target = keys.find(x=>x.k===k).el;
      if (target){ target.src = item.src || makeSmallPlaceholder('image'); target.style.opacity='0'; requestAnimationFrame(()=> requestAnimationFrame(()=>{ target.style.opacity='1'; target.style.transition='opacity 0.18s ease'; })); }
    }).catch(()=>{
      const target = keys.find(x=>x.k===k).el; if (target) target.src = makeSmallPlaceholder('åŠ è½½å¤±è´¥');
    });
  });

  // ç­‰å¾…ä¸»å›¾å¿«é€Ÿè¿”å›æˆ–çŸ­è¶…æ—¶
  try{ await Promise.race([ promises[0], new Promise((_,rej)=>setTimeout(()=>rej('timeout'),1200)) ]); }catch(e){}

  await Promise.allSettled(promises);
  hideLoading();
  preloadAdjacent(itemIndex);
}

/* ------------------ æ¸²æŸ“æ ‡ç­¾ & äº¤äº’ ------------------ */
function renderTabs(){ tabs.innerHTML=''; ITEMS.forEach((it,idx)=>{
  const el = document.createElement('button'); el.type='button'; el.className='tab' + (idx===0? ' active':''); el.dataset.index=idx; el.setAttribute('aria-pressed', idx===0?'true':'false'); el.innerHTML=`<span class=\"icon\">${it.icon}</span><span>${it.title}</span>`;
  el.addEventListener('mouseenter', ()=>{ const i=parseInt(el.dataset.index); if (!isNaN(i)) preloadAdjacent(i); });
  el.addEventListener('touchstart', ()=>{ const i=parseInt(el.dataset.index); if (!isNaN(i)) preloadAdjacent(i); },{passive:true});
  el.addEventListener('click', async ()=>{ document.querySelectorAll('.tab').forEach(t=>{ t.classList.remove('active'); t.setAttribute('aria-pressed','false'); }); el.classList.add('active'); el.setAttribute('aria-pressed','true'); await switchToItem(parseInt(el.dataset.index)); });
  tabs.appendChild(el);
}); }

// copy
document.getElementById('btn-copy').addEventListener('click', ()=>{ const text = `${detailTitle.textContent}\n${detailSub.textContent}\né…æ–¹ï¼š${detailFormula.textContent}`; if (navigator.clipboard && navigator.clipboard.writeText) navigator.clipboard.writeText(text).then(()=>alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿')).catch(()=>fallbackCopy(text)); else fallbackCopy(text); });
function fallbackCopy(text){ const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); try{ document.execCommand('copy'); alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'); }catch(e){ alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶:\n'+text);} ta.remove(); }

/* ------------------ åˆå§‹åŒ– ------------------ */
window.addEventListener('beforeunload', ()=>{ // æ¸…ç† object URLs
  imageCache.forEach(val=>{ if (val && val.src) try{ URL.revokeObjectURL(val.src); }catch(e){} });
});

document.addEventListener('DOMContentLoaded', async ()=>{
  renderTabs();
  // å…ˆå¿«é€Ÿå¹¶ä¼˜å…ˆåŠ è½½ 0 çš„ä¸»å›¾ä¸å½“å‰é¡µé¢æ‰€éœ€å°é‡èµ„æº
  const initial = [0];
  let lastPct = 0;
  function onProgress(pct){ lastPct=pct; progressBar.style.width = pct + '%'; progressPercent.textContent = pct + '%'; }

  // åˆå§‹åŒ–ä¼˜å…ˆåŠ è½½ï¼šæŠŠæ¯ä¸ªæ¡ç›®çš„ product(ä¸»å›¾) å…ˆä½œä¸ºåˆå§‹é˜Ÿåˆ—ï¼Œä»¥æé«˜åˆ‡æ¢æ—¶å‘½ä¸­ç‡
  const indexList = ITEMS.map((_,i)=>i);
  // 1) å…ˆå¹¶è¡ŒåŠ è½½æ‰€æœ‰ productï¼ˆä¼˜å…ˆï¼‰ï¼Œä»¥å‡å°‘åˆ‡æ¢ä¸»å›¾çš„ç­‰å¾…
  const productTasks = indexList.map(i=> smartLoadImage(i,'product',{priority:false}).catch(()=>{}));
  // 2) åœ¨åå°ç»§ç»­åŠ è½½åœºæ™¯å›¾ï¼Œä½†ä¸é˜»å¡é¦–å±ï¼šä½¿ç”¨æ‰¹é‡æ–¹å¼
  const sceneTasks = [];
  indexList.forEach(i=>{ ['scene1','scene2'].forEach(t=> sceneTasks.push(()=> smartLoadImage(i,t,{priority:false}).catch(()=>{}))); });

  // è¿›åº¦ï¼šäº§å“å›¾å®Œæˆæ¯”ä¾‹ä½œä¸ºé¢„åŠ è½½è¿›åº¦åŸºç¡€
  const totalProducts = productTasks.length;
  let doneProducts = 0;
  productTasks.forEach(p=> p.then(()=>{ doneProducts++; const pct = Math.round((doneProducts/totalProducts)*60); onProgress(pct); }).catch(()=>{ doneProducts++; const pct = Math.round((doneProducts/totalProducts)*60); onProgress(pct); }));

  // ç­‰å¾…äº§å“å›¾ä¸»è¦å®Œæˆæˆ–çŸ­è¶…æ—¶
  try{ await Promise.race([ Promise.all(productTasks), new Promise((_,rej)=>setTimeout(()=>rej('timeout'),7000)) ]); }catch(e){}
  onProgress(70);

  // ç»§ç»­æ‰¹é‡åŠ è½½åœºæ™¯å›¾ï¼Œå¹¶æ›´æ–°è¿›åº¦
  const batch = 6; let completed = 0; const totalScenes = sceneTasks.length;
  for (let i=0;i<sceneTasks.length;i+=batch){ const batchFns = sceneTasks.slice(i,i+batch).map(fn=>fn()); await Promise.allSettled(batchFns); completed+=batchFns.length; const pct = 70 + Math.round((completed/totalScenes)*30); onProgress(Math.min(100,pct)); }

  // å°å»¶è¿Ÿç¡®ä¿ç”¨æˆ·çœ‹è§ 100%
  await new Promise(r=>setTimeout(r,200));

  // éšè— preloader
  preloader.setAttribute('aria-hidden','true'); preloader.style.display='none'; document.getElementById('appContent').style.visibility='visible';

  // æ‰“å¼€é¡µé¢åï¼Œç‚¹å‡»ç¬¬ä¸€ä¸ªtabè§¦å‘å±•ç¤ºï¼ˆä¼šå‘½ä¸­å·²åŠ è½½çš„ä¸»å›¾ï¼‰
  const first = document.querySelector('.tab'); if (first) first.click();

  // åå°ç»§ç»­ç¡®ä¿ä»»ä½•æœªåŠ è½½çš„èµ„æºè¡¥é½
  setTimeout(()=>{ // small delay to let UI settle
    const remainingIndices = ITEMS.map((_,i)=>i);
    preloadMultipleImages(remainingIndices).catch(()=>{});
  }, 500);
});
</script>
</body>
</html>